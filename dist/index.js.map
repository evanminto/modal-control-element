{"mappings":"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","sources":["src/index.js","src/ModalControlElement.js","src/ModalController.js","src/isEventInsideElement.js"],"sourcesContent":["import ModalControlElement from './ModalControlElement.js';\nimport ModalController from './ModalController.js';\n\n/**\n * @param {string} [name]\n * @returns {void}\n */\nconst define = (name = 'modal-control') => {\n  if ('customElements' in window) {\n    customElements.define(name, ModalControlElement);\n  }\n};\n\nexport { ModalControlElement, ModalController, define };\n","import ModalController from \"./ModalController.js\";\n\n/**\n * @customElement modal-control\n * @attr target - ID of the target `<dialog>`\n * @attr {'toggle'|'show'|'hide'} target-action - What should happen to the dialog when clicking the control (default: 'toggle')\n * @attr light-dismiss - If present, the modal will be closeable by clicking outside of it\n * @fires modal-control-before-toggle\n * @fires modal-control-toggle\n */\nexport default class ModalControlElement extends HTMLElement {\n  /** @type {string | null} */\n  #target = null;\n  /** @type {'toggle' | 'show' | 'hide'} */\n  #targetAction = 'toggle';\n  /** @type {boolean} */\n  #lightDismiss = false;\n  /** @type {ModalController | undefined} */\n  #controller;\n\n  static observedAttributes = ['target', 'target-action', 'light-dismiss'];\n\n  /**\n   * @param {string}  name\n   * @param {string | undefined}     _oldVal\n   * @param {string | undefined}     newVal\n   */\n  attributeChangedCallback(name, _oldVal, newVal) {\n    if (name === 'target') {\n      this.#target = newVal || null;\n    }\n\n    if (\n      name === 'target-action' &&\n      newVal &&\n      ['toggle', 'show', 'hide'].includes(newVal)\n    ) {\n      this.#targetAction = /** @type {'toggle' | 'show' | 'hide'} */ (newVal);\n    }\n\n    if (name === 'light-dismiss') {\n      this.#lightDismiss = newVal !== undefined;\n    }\n\n    if (name === 'target' || name === 'light-dismiss') {\n      const root = this.getRootNode();\n      const { targetElement } = this;\n\n      if (\n        targetElement instanceof HTMLDialogElement &&\n        (root instanceof Document || root instanceof ShadowRoot)\n      ) {\n        this.#controller = new ModalController(targetElement, {\n          lightDismiss: this.#lightDismiss,\n          canToggle: () => this.#dispatchBeforeToggle(),\n          onToggle: () => this.#dispatchToggle(),\n        });\n      }\n    }\n  }\n\n  /**\n   * ID of the target `<dialog>`\n   * @type {string|null}\n   */\n  get target() {\n    return this.#target;\n  }\n\n  set target(value) {\n    this.#target = value;\n\n    if (value === null) {\n      this.removeAttribute('target');\n    } else {\n      this.setAttribute('target', value);\n    }\n  }\n\n  /**\n   * What should happen to the dialog when clicking the control (default: 'toggle')\n   * @type {'toggle'|'show'|'hide'}\n   */\n  get targetAction() {\n    return this.#targetAction;\n  }\n\n  set targetAction(value) {\n    if (!value) {\n      return;\n    }\n\n    this.#targetAction = value;\n\n    if (value === null) {\n      this.removeAttribute('target-action');\n    } else {\n      this.setAttribute('target-action', value);\n    }\n  }\n\n  /**\n   * Determines how the user can close the target modal\n   * @type {boolean}\n   */\n  get lightDismiss() {\n    return this.#lightDismiss;\n  }\n\n  set lightDismiss(value) {\n    this.#lightDismiss = Boolean(value);\n\n    if (this.#lightDismiss) {\n      this.setAttribute('light-dismiss', '');\n    } else {\n      this.removeAttribute('light-dismiss');\n    }\n  }\n\n  /** @type {HTMLDialogElement|null} */\n  get targetElement() {\n    const root = /** @type {Document|ShadowRoot} */ (this.getRootNode());\n    const el = this.target ? root.getElementById(this.target) : null;\n\n    if (!(el instanceof HTMLDialogElement)) {\n      return null;\n    }\n\n    return el;\n  }\n\n  connectedCallback() {\n    this.addEventListener('click', this.#handleClick);\n  }\n\n  disconnectedCallback() {\n    this.removeEventListener('click', this.#handleClick);\n  }\n\n  /** @returns {boolean} */\n  #dispatchBeforeToggle() {\n    return this.dispatchEvent(\n      new Event('modal-control-before-toggle', { cancelable: true })\n    );\n  }\n\n  /** @returns {boolean} */\n  #dispatchToggle() {\n    return this.dispatchEvent(new Event('modal-control-toggle'));\n  }\n\n  /**\n   * @param {MouseEvent} event\n   * @returns {void}\n   */\n  #handleClick = event => {\n    const target = /** @type {Element} */ (event.target);\n\n    if (!target.closest('button, input[type=\"button\"]')) {\n      return;\n    }\n\n    switch (this.targetAction) {\n      case 'show':\n        this.#controller?.show();\n        break;\n      case 'hide':\n        this.#controller?.hide();\n        break;\n      case 'toggle':\n        this.#controller?.toggle();\n        break;\n    }\n  };\n}\n","import isEventInsideElement from \"./isEventInsideElement.js\";\n\n/**\n * @typedef {{\n *   lightDismiss?: boolean;\n *   canToggle?: () => boolean;\n *   onToggle?: () => void;\n * }} ModalOptions\n */\n\nexport default class ModalController {\n  #dialog;\n  #options;\n  \n  /**\n   * @param {HTMLDialogElement} dialog\n   * @param {ModalOptions} [options]\n   */\n  constructor(dialog, options) {\n    const defaultOptions = { canToggle: () => true };\n\n    this.#dialog = dialog;\n    this.#options = Object.assign(defaultOptions, options);\n  }\n\n  show() {\n    if (this.#dialog.matches(':modal') || !this.#options.canToggle?.()) {\n      return;\n    }\n    \n    const abortController = new AbortController();\n    this.#dialog.showModal();\n\n    if (this.#options.lightDismiss) {\n      this.#dialog.addEventListener(\n        'click',\n        (event) => {\n          if (!(event instanceof MouseEvent) || isEventInsideElement(event, this.#dialog)) {\n            return;\n          }\n\n          this.#dialog.close();\n        },\n        { signal: abortController.signal }\n      );\n\n      setTimeout(() => {\n        this.#dialog.getRootNode().addEventListener(\n          'click',\n          (event) => {\n            if (!(event.target instanceof Node) || !this.#dialog.contains(event.target)) {\n              return;\n            }\n\n            this.#dialog.close();\n          },\n          { signal: abortController.signal }\n        );\n\n        this.#dialog.addEventListener(\n          'close',\n          () => abortController.abort(),\n          { signal: abortController.signal }\n        );\n      }, 0);\n    }\n\n    this.#options.onToggle?.();\n  }\n\n  hide() {\n    if (this.#dialog.matches(':not(:modal)') || !this.#options.canToggle?.()) {\n      return;\n    }\n\n    this.#dialog.close();\n    this.#options.onToggle?.();\n  }\n\n  toggle() {\n    if (this.#dialog.matches(':modal')) {\n      this.hide();\n    } else {\n      this.show();\n    }\n  }\n}\n","/**\n * @param {MouseEvent}  event\n * @param {HTMLDialogElement} dialog\n * @returns {boolean}\n */\nexport default function isEventInsideElement(event, dialog) {\n  const { clientX, clientY} = event;\n  const target = /** @type {Node} */ (event.target);\n  const { x, y, width, height } = dialog.getBoundingClientRect();\n\n  // If the target IS the dialog, check that the event is inside the bounds. A\n  // click on the backdrop of a dialog will appear as a click on the dialog\n  // itself, but will be outside the bounds.\n  if (dialog === target) {\n    return (\n      clientX >= x &&\n      clientX <= x + width &&\n      clientY >= y &&\n      clientY <= y + height\n    );\n  }\n\n  // If the target isn't the dialog itself, check that it's inside the dialog\n  return dialog.contains(target);\n}"],"names":[],"version":3,"file":"index.js.map"}