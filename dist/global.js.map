{"mappings":"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","sources":["<anon>","src/global.js","src/index.js","src/ModalControlElement.js","src/ModalController.js","src/isEventInsideElement.js"],"sourcesContent":["(() => {\n/**\n * @param {MouseEvent}  event\n * @param {HTMLDialogElement} dialog\n * @returns {boolean}\n */ function $01775cf5aedf1ce5$export$2e2bcd8739ae039(event, dialog) {\n    const { clientX: clientX, clientY: clientY } = event;\n    const target = /** @type {Node} */ event.target;\n    const { x: x, y: y, width: width, height: height } = dialog.getBoundingClientRect();\n    // If the target IS the dialog, check that the event is inside the bounds. A\n    // click on the backdrop of a dialog will appear as a click on the dialog\n    // itself, but will be outside the bounds.\n    if (dialog === target) return clientX >= x && clientX <= x + width && clientY >= y && clientY <= y + height;\n    // If the target isn't the dialog itself, check that it's inside the dialog\n    return dialog.contains(target);\n}\n\n\nclass $c4fcd758eb800389$export$2e2bcd8739ae039 {\n    #dialog;\n    #options;\n    /**\n   * @param {HTMLDialogElement} dialog\n   * @param {ModalOptions} [options]\n   */ constructor(dialog, options){\n        const defaultOptions = {\n            canToggle: ()=>true\n        };\n        this.#dialog = dialog;\n        this.#options = Object.assign(defaultOptions, options);\n    }\n    show() {\n        if (this.#dialog.matches(\":modal\") || !this.#options.canToggle?.()) return;\n        const abortController = new AbortController();\n        this.#dialog.showModal();\n        if (this.#options.lightDismiss) {\n            this.#dialog.addEventListener(\"click\", (event)=>{\n                if (!(event instanceof MouseEvent) || (0, $01775cf5aedf1ce5$export$2e2bcd8739ae039)(event, this.#dialog)) return;\n                this.hide();\n            }, {\n                signal: abortController.signal\n            });\n            setTimeout(()=>{\n                this.#dialog.getRootNode().addEventListener(\"click\", (event)=>{\n                    if (!(event.target instanceof Node) || this.#dialog.contains(event.target)) return;\n                    this.hide();\n                }, {\n                    signal: abortController.signal\n                });\n                this.#dialog.addEventListener(\"close\", ()=>abortController.abort(), {\n                    signal: abortController.signal\n                });\n            }, 0);\n        }\n        this.#options.onToggle?.();\n    }\n    hide() {\n        if (this.#dialog.matches(\":not(:modal)\") || !this.#options.canToggle?.()) return;\n        this.#dialog.close();\n        this.#options.onToggle?.();\n    }\n    toggle() {\n        if (this.#dialog.matches(\":modal\")) this.hide();\n        else this.show();\n    }\n}\n\n\nclass $1c1612fc3437cf32$export$2e2bcd8739ae039 extends HTMLElement {\n    /** @type {string | null} */ #target = null;\n    /** @type {'toggle' | 'show' | 'hide'} */ #targetAction = \"toggle\";\n    /** @type {boolean} */ #lightDismiss = false;\n    /** @type {ModalController | undefined} */ #controller;\n    static observedAttributes = [\n        \"target\",\n        \"target-action\",\n        \"light-dismiss\"\n    ];\n    /**\n   * @param {string}  name\n   * @param {string | undefined}     _oldVal\n   * @param {string | undefined}     newVal\n   */ attributeChangedCallback(name, _oldVal, newVal) {\n        if (name === \"target\") this.#target = newVal || null;\n        if (name === \"target-action\" && newVal && [\n            \"toggle\",\n            \"show\",\n            \"hide\"\n        ].includes(newVal)) this.#targetAction = /** @type {'toggle' | 'show' | 'hide'} */ newVal;\n        if (name === \"light-dismiss\") this.#lightDismiss = newVal !== undefined;\n        if (name === \"target\" || name === \"light-dismiss\") {\n            const root = this.getRootNode();\n            const { targetElement: targetElement } = this;\n            if (targetElement instanceof HTMLDialogElement && (root instanceof Document || root instanceof ShadowRoot)) this.#controller = new (0, $c4fcd758eb800389$export$2e2bcd8739ae039)(targetElement, {\n                lightDismiss: this.#lightDismiss,\n                canToggle: ()=>this.#dispatchBeforeToggle(),\n                onToggle: ()=>this.#dispatchToggle()\n            });\n        }\n    }\n    /**\n   * ID of the target `<dialog>`\n   * @type {string|null}\n   */ get target() {\n        return this.#target;\n    }\n    set target(value) {\n        this.#target = value;\n        if (value === null) this.removeAttribute(\"target\");\n        else this.setAttribute(\"target\", value);\n    }\n    /**\n   * What should happen to the dialog when clicking the control (default: 'toggle')\n   * @type {'toggle'|'show'|'hide'}\n   */ get targetAction() {\n        return this.#targetAction;\n    }\n    set targetAction(value) {\n        if (!value) return;\n        this.#targetAction = value;\n        if (value === null) this.removeAttribute(\"target-action\");\n        else this.setAttribute(\"target-action\", value);\n    }\n    /**\n   * Determines how the user can close the target modal\n   * @type {boolean}\n   */ get lightDismiss() {\n        return this.#lightDismiss;\n    }\n    set lightDismiss(value) {\n        this.#lightDismiss = Boolean(value);\n        if (this.#lightDismiss) this.setAttribute(\"light-dismiss\", \"\");\n        else this.removeAttribute(\"light-dismiss\");\n    }\n    /** @type {HTMLDialogElement|null} */ get targetElement() {\n        const root = /** @type {Document|ShadowRoot} */ this.getRootNode();\n        const el = this.target ? root.getElementById(this.target) : null;\n        if (!(el instanceof HTMLDialogElement)) return null;\n        return el;\n    }\n    connectedCallback() {\n        this.addEventListener(\"click\", this.#handleClick);\n    }\n    disconnectedCallback() {\n        this.removeEventListener(\"click\", this.#handleClick);\n    }\n    /** @returns {boolean} */ #dispatchBeforeToggle() {\n        return this.dispatchEvent(new Event(\"modal-control-before-toggle\", {\n            cancelable: true\n        }));\n    }\n    /** @returns {boolean} */ #dispatchToggle() {\n        return this.dispatchEvent(new Event(\"modal-control-toggle\"));\n    }\n    /**\n   * @param {MouseEvent} event\n   * @returns {void}\n   */ #handleClick = (event)=>{\n        const target = /** @type {Element} */ event.target;\n        if (!target.closest('button, input[type=\"button\"]')) return;\n        switch(this.targetAction){\n            case \"show\":\n                this.#controller?.show();\n                break;\n            case \"hide\":\n                this.#controller?.hide();\n                break;\n            case \"toggle\":\n                this.#controller?.toggle();\n                break;\n        }\n    };\n}\n\n\n\n/**\n * @param {string} [name]\n * @returns {void}\n */ const $f9ccc1fa0d22629a$export$f36d6a7a5c09a23e = (name = \"modal-control\")=>{\n    if (\"customElements\" in window) customElements.define(name, (0, $1c1612fc3437cf32$export$2e2bcd8739ae039));\n};\n\n\n(0, $f9ccc1fa0d22629a$export$f36d6a7a5c09a23e)();\n\n})();\n//# sourceMappingURL=global.js.map\n","import { define } from \"./index.js\";\n\ndefine();\n","import ModalControlElement from './ModalControlElement.js';\nimport ModalController from './ModalController.js';\n\n/**\n * @param {string} [name]\n * @returns {void}\n */\nconst define = (name = 'modal-control') => {\n  if ('customElements' in window) {\n    customElements.define(name, ModalControlElement);\n  }\n};\n\nexport { ModalControlElement, ModalController, define };\n","import ModalController from \"./ModalController.js\";\n\n/**\n * @customElement modal-control\n * @attr target - ID of the target `<dialog>`\n * @attr {'toggle'|'show'|'hide'} target-action - What should happen to the dialog when clicking the control (default: 'toggle')\n * @attr light-dismiss - If present, the modal will be closeable by clicking outside of it\n * @fires modal-control-before-toggle\n * @fires modal-control-toggle\n */\nexport default class ModalControlElement extends HTMLElement {\n  /** @type {string | null} */\n  #target = null;\n  /** @type {'toggle' | 'show' | 'hide'} */\n  #targetAction = 'toggle';\n  /** @type {boolean} */\n  #lightDismiss = false;\n  /** @type {ModalController | undefined} */\n  #controller;\n\n  static observedAttributes = ['target', 'target-action', 'light-dismiss'];\n\n  /**\n   * @param {string}  name\n   * @param {string | undefined}     _oldVal\n   * @param {string | undefined}     newVal\n   */\n  attributeChangedCallback(name, _oldVal, newVal) {\n    if (name === 'target') {\n      this.#target = newVal || null;\n    }\n\n    if (\n      name === 'target-action' &&\n      newVal &&\n      ['toggle', 'show', 'hide'].includes(newVal)\n    ) {\n      this.#targetAction = /** @type {'toggle' | 'show' | 'hide'} */ (newVal);\n    }\n\n    if (name === 'light-dismiss') {\n      this.#lightDismiss = newVal !== undefined;\n    }\n\n    if (name === 'target' || name === 'light-dismiss') {\n      const root = this.getRootNode();\n      const { targetElement } = this;\n\n      if (\n        targetElement instanceof HTMLDialogElement &&\n        (root instanceof Document || root instanceof ShadowRoot)\n      ) {\n        this.#controller = new ModalController(targetElement, {\n          lightDismiss: this.#lightDismiss,\n          canToggle: () => this.#dispatchBeforeToggle(),\n          onToggle: () => this.#dispatchToggle(),\n        });\n      }\n    }\n  }\n\n  /**\n   * ID of the target `<dialog>`\n   * @type {string|null}\n   */\n  get target() {\n    return this.#target;\n  }\n\n  set target(value) {\n    this.#target = value;\n\n    if (value === null) {\n      this.removeAttribute('target');\n    } else {\n      this.setAttribute('target', value);\n    }\n  }\n\n  /**\n   * What should happen to the dialog when clicking the control (default: 'toggle')\n   * @type {'toggle'|'show'|'hide'}\n   */\n  get targetAction() {\n    return this.#targetAction;\n  }\n\n  set targetAction(value) {\n    if (!value) {\n      return;\n    }\n\n    this.#targetAction = value;\n\n    if (value === null) {\n      this.removeAttribute('target-action');\n    } else {\n      this.setAttribute('target-action', value);\n    }\n  }\n\n  /**\n   * Determines how the user can close the target modal\n   * @type {boolean}\n   */\n  get lightDismiss() {\n    return this.#lightDismiss;\n  }\n\n  set lightDismiss(value) {\n    this.#lightDismiss = Boolean(value);\n\n    if (this.#lightDismiss) {\n      this.setAttribute('light-dismiss', '');\n    } else {\n      this.removeAttribute('light-dismiss');\n    }\n  }\n\n  /** @type {HTMLDialogElement|null} */\n  get targetElement() {\n    const root = /** @type {Document|ShadowRoot} */ (this.getRootNode());\n    const el = this.target ? root.getElementById(this.target) : null;\n\n    if (!(el instanceof HTMLDialogElement)) {\n      return null;\n    }\n\n    return el;\n  }\n\n  connectedCallback() {\n    this.addEventListener('click', this.#handleClick);\n  }\n\n  disconnectedCallback() {\n    this.removeEventListener('click', this.#handleClick);\n  }\n\n  /** @returns {boolean} */\n  #dispatchBeforeToggle() {\n    return this.dispatchEvent(\n      new Event('modal-control-before-toggle', { cancelable: true })\n    );\n  }\n\n  /** @returns {boolean} */\n  #dispatchToggle() {\n    return this.dispatchEvent(new Event('modal-control-toggle'));\n  }\n\n  /**\n   * @param {MouseEvent} event\n   * @returns {void}\n   */\n  #handleClick = event => {\n    const target = /** @type {Element} */ (event.target);\n\n    if (!target.closest('button, input[type=\"button\"]')) {\n      return;\n    }\n\n    switch (this.targetAction) {\n      case 'show':\n        this.#controller?.show();\n        break;\n      case 'hide':\n        this.#controller?.hide();\n        break;\n      case 'toggle':\n        this.#controller?.toggle();\n        break;\n    }\n  };\n}\n","import isEventInsideElement from \"./isEventInsideElement.js\";\n\n/**\n * @typedef {{\n *   lightDismiss?: boolean;\n *   canToggle?: () => boolean;\n *   onToggle?: () => void;\n * }} ModalOptions\n */\n\nexport default class ModalController {\n  #dialog;\n  #options;\n  \n  /**\n   * @param {HTMLDialogElement} dialog\n   * @param {ModalOptions} [options]\n   */\n  constructor(dialog, options) {\n    const defaultOptions = { canToggle: () => true };\n\n    this.#dialog = dialog;\n    this.#options = Object.assign(defaultOptions, options);\n  }\n\n  show() {\n    if (this.#dialog.matches(':modal') || !this.#options.canToggle?.()) {\n      return;\n    }\n    \n    const abortController = new AbortController();\n    this.#dialog.showModal();\n\n    if (this.#options.lightDismiss) {\n      this.#dialog.addEventListener(\n        'click',\n        (event) => {\n          if (!(event instanceof MouseEvent) || isEventInsideElement(event, this.#dialog)) {\n            return;\n          }\n\n          this.hide();\n        },\n        { signal: abortController.signal }\n      );\n\n      setTimeout(() => {\n        this.#dialog.getRootNode().addEventListener(\n          'click',\n          (event) => {\n            if (!(event.target instanceof Node) || this.#dialog.contains(event.target)) {\n              return;\n            }\n\n            this.hide();\n          },\n          { signal: abortController.signal }\n        );\n\n        this.#dialog.addEventListener(\n          'close',\n          () => abortController.abort(),\n          { signal: abortController.signal }\n        );\n      }, 0);\n    }\n\n    this.#options.onToggle?.();\n  }\n\n  hide() {\n    if (this.#dialog.matches(':not(:modal)') || !this.#options.canToggle?.()) {\n      return;\n    }\n\n    this.#dialog.close();\n    this.#options.onToggle?.();\n  }\n\n  toggle() {\n    if (this.#dialog.matches(':modal')) {\n      this.hide();\n    } else {\n      this.show();\n    }\n  }\n}\n","/**\n * @param {MouseEvent}  event\n * @param {HTMLDialogElement} dialog\n * @returns {boolean}\n */\nexport default function isEventInsideElement(event, dialog) {\n  const { clientX, clientY} = event;\n  const target = /** @type {Node} */ (event.target);\n  const { x, y, width, height } = dialog.getBoundingClientRect();\n\n  // If the target IS the dialog, check that the event is inside the bounds. A\n  // click on the backdrop of a dialog will appear as a click on the dialog\n  // itself, but will be outside the bounds.\n  if (dialog === target) {\n    return (\n      clientX >= x &&\n      clientX <= x + width &&\n      clientY >= y &&\n      clientY <= y + height\n    );\n  }\n\n  // If the target isn't the dialog itself, check that it's inside the dialog\n  return dialog.contains(target);\n}"],"names":["$c4fcd758eb800389$export$2e2bcd8739ae039","dialog","options","constructor","Object","assign","canToggle","show","matches","abortController","AbortController","showModal","lightDismiss","addEventListener","event","MouseEvent","clientX","clientY","target","x","y","width","height","getBoundingClientRect","contains","hide","signal","setTimeout","getRootNode","Node","abort","onToggle","close","toggle","$1c1612fc3437cf32$export$2e2bcd8739ae039","HTMLElement","targetAction","controller","observedAttributes","attributeChangedCallback","name","_oldVal","newVal","includes","undefined","root","targetElement","HTMLDialogElement","Document","ShadowRoot","dispatchBeforeToggle","dispatchToggle","value","removeAttribute","setAttribute","Boolean","el","getElementById","connectedCallback","handleClick","disconnectedCallback","removeEventListener","dispatchEvent","Event","cancelable","closest","window","customElements","define"],"version":3,"file":"global.js.map"}