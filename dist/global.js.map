{"mappings":"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","sources":["<anon>","src/global.js","src/index.js","src/ModalControlElement.js","src/ModalController.js","src/deepContains.js","src/isEventInsideElement.js"],"sourcesContent":["(() => {\n/**\n * Checks if an ancestor node contains a descendant node, crossing shadow\n * boundaries\n * @param {Node} ancestor\n * @param {Node} descendant\n */ function $94c65141d6f98e31$export$273cb3019e2f952c(ancestor, descendant) {\n    // First, check via normal contains (fastest, but doesn't work with shadow\n    // roots)\n    if (ancestor.contains(descendant)) return true;\n    // This could be a shadow root or a document\n    const root = descendant.getRootNode();\n    if (root instanceof ShadowRoot) // Check the host of the shadow root\n    return $94c65141d6f98e31$export$273cb3019e2f952c(ancestor, root.host);\n    // If it's not a shadow root and contains() returned false, it's definitely\n    // not a match\n    return false;\n}\n\n\n\nfunction $01775cf5aedf1ce5$export$2e2bcd8739ae039(event, dialog) {\n    const { clientX: clientX, clientY: clientY } = event;\n    const target = /** @type {Node} */ event.target;\n    const { x: x, y: y, width: width, height: height } = dialog.getBoundingClientRect();\n    // If the target IS the dialog, check that the event is inside the bounds. A\n    // click on the backdrop of a dialog will appear as a click on the dialog\n    // itself, but will be outside the bounds.\n    if (dialog === target) return clientX >= x && clientX <= x + width && clientY >= y && clientY <= y + height;\n    // If the target isn't the dialog itself, check that it's inside the dialog\n    return (0, $94c65141d6f98e31$export$273cb3019e2f952c)(dialog, target);\n}\n\n\nclass $c4fcd758eb800389$export$2e2bcd8739ae039 {\n    #dialogOrGetter;\n    #options;\n    /**\n   * @param {HTMLDialogElement | (() => HTMLDialogElement?)} dialog Element or getter\n   * @param {ModalOptions} [options]\n   */ constructor(dialog, options){\n        const defaultOptions = {\n            canToggle: ()=>true\n        };\n        this.#dialogOrGetter = dialog;\n        this.#options = Object.assign(defaultOptions, options);\n    }\n    show() {\n        const dialog = this.#getDialog();\n        if (!dialog || dialog.matches(\":modal\") || !this.#options.canToggle?.()) return;\n        const abortController = new AbortController();\n        dialog.showModal();\n        if (this.#options.lightDismiss) {\n            dialog.addEventListener(\"click\", (event)=>{\n                if (!(event instanceof MouseEvent) || (0, $01775cf5aedf1ce5$export$2e2bcd8739ae039)(event, dialog)) return;\n                this.hide();\n            }, {\n                signal: abortController.signal\n            });\n            setTimeout(()=>{\n                const root = dialog.getRootNode();\n                /** @param {Event} event */ const handleClickDirectRoot = (event)=>{\n                    // If the click is inside the dialog, ignore it\n                    if (!(event instanceof MouseEvent) || (0, $01775cf5aedf1ce5$export$2e2bcd8739ae039)(event, dialog)) return;\n                    this.hide();\n                };\n                if (root instanceof ShadowRoot) {\n                    root.addEventListener(\"click\", handleClickDirectRoot, {\n                        signal: abortController.signal\n                    });\n                    dialog.getRootNode({\n                        composed: true\n                    }).addEventListener(\"click\", (event)=>{\n                        // If the target is an ancestor of the dialog, ignore the click\n                        // (the shadow click handler should take care of anything inside\n                        // the target that's not the dialog)\n                        if (!(event.target instanceof Node) || (0, $94c65141d6f98e31$export$273cb3019e2f952c)(event.target, dialog)) return;\n                        this.hide();\n                    }, {\n                        signal: abortController.signal\n                    });\n                } else root.addEventListener(\"click\", handleClickDirectRoot, {\n                    signal: abortController.signal\n                });\n                dialog.addEventListener(\"close\", ()=>abortController.abort(), {\n                    signal: abortController.signal\n                });\n            }, 0);\n        }\n        this.#options.onToggle?.();\n    }\n    hide() {\n        const dialog = this.#getDialog();\n        if (!dialog || dialog.matches(\":not(:modal)\") || !this.#options.canToggle?.()) return;\n        dialog.close();\n        this.#options.onToggle?.();\n    }\n    toggle() {\n        if (this.#getDialog()?.matches(\":modal\")) this.hide();\n        else this.show();\n    }\n    #getDialog() {\n        if (typeof this.#dialogOrGetter === \"function\") return this.#dialogOrGetter();\n        return this.#dialogOrGetter;\n    }\n}\n\n\nclass $1c1612fc3437cf32$export$2e2bcd8739ae039 extends HTMLElement {\n    /** @type {string | null} */ #target = null;\n    /** @type {'toggle' | 'show' | 'hide'} */ #targetAction = \"toggle\";\n    /** @type {boolean} */ #lightDismiss = false;\n    /** @type {ModalController | undefined} */ #controller;\n    static observedAttributes = [\n        \"target\",\n        \"target-action\",\n        \"light-dismiss\"\n    ];\n    /**\n   * @param {string}  name\n   * @param {string | undefined}     _oldVal\n   * @param {string | undefined}     newVal\n   */ attributeChangedCallback(name, _oldVal, newVal) {\n        if (name === \"target\") this.#target = newVal || null;\n        if (name === \"target-action\" && newVal && [\n            \"toggle\",\n            \"show\",\n            \"hide\"\n        ].includes(newVal)) this.#targetAction = /** @type {'toggle' | 'show' | 'hide'} */ newVal;\n        if (name === \"light-dismiss\") this.#lightDismiss = newVal !== undefined;\n        if (name === \"target\" || name === \"light-dismiss\") this.#initController();\n    }\n    /**\n   * ID of the target `<dialog>`\n   * @type {string|null}\n   */ get target() {\n        return this.#target;\n    }\n    set target(value) {\n        this.#target = value;\n        if (value === null) this.removeAttribute(\"target\");\n        else this.setAttribute(\"target\", value);\n    }\n    /**\n   * What should happen to the dialog when clicking the control (default: 'toggle')\n   * @type {'toggle'|'show'|'hide'}\n   */ get targetAction() {\n        return this.#targetAction;\n    }\n    set targetAction(value) {\n        if (!value) return;\n        this.#targetAction = value;\n        if (value === null) this.removeAttribute(\"target-action\");\n        else this.setAttribute(\"target-action\", value);\n    }\n    /**\n   * Determines how the user can close the target modal\n   * @type {boolean}\n   */ get lightDismiss() {\n        return this.#lightDismiss;\n    }\n    set lightDismiss(value) {\n        this.#lightDismiss = Boolean(value);\n        if (this.#lightDismiss) this.setAttribute(\"light-dismiss\", \"\");\n        else this.removeAttribute(\"light-dismiss\");\n    }\n    /** @type {HTMLDialogElement|null} */ get targetElement() {\n        const root = /** @type {Document|ShadowRoot} */ this.getRootNode();\n        const el = this.target ? root.getElementById(this.target) : null;\n        if (!(el instanceof HTMLDialogElement)) return null;\n        return el;\n    }\n    connectedCallback() {\n        this.addEventListener(\"click\", this.#handleClick);\n        this.#initController();\n    }\n    disconnectedCallback() {\n        this.removeEventListener(\"click\", this.#handleClick);\n    }\n    #initController() {\n        const root = this.getRootNode();\n        if (root instanceof Document || root instanceof ShadowRoot) this.#controller = new (0, $c4fcd758eb800389$export$2e2bcd8739ae039)(()=>this.targetElement, {\n            lightDismiss: this.#lightDismiss,\n            canToggle: ()=>this.#dispatchBeforeToggle(),\n            onToggle: ()=>this.#dispatchToggle()\n        });\n    }\n    /** @returns {boolean} */ #dispatchBeforeToggle() {\n        return this.dispatchEvent(new Event(\"modal-control-before-toggle\", {\n            cancelable: true\n        }));\n    }\n    /** @returns {boolean} */ #dispatchToggle() {\n        return this.dispatchEvent(new Event(\"modal-control-toggle\"));\n    }\n    /**\n   * @param {MouseEvent} event\n   * @returns {void}\n   */ #handleClick = (event)=>{\n        const target = /** @type {Element} */ event.target;\n        if (!target.closest('button, input[type=\"button\"]')) return;\n        switch(this.targetAction){\n            case \"show\":\n                this.#controller?.show();\n                break;\n            case \"hide\":\n                this.#controller?.hide();\n                break;\n            case \"toggle\":\n                this.#controller?.toggle();\n                break;\n        }\n    };\n}\n\n\n\n/**\n * @param {string} [name]\n * @returns {void}\n */ const $f9ccc1fa0d22629a$export$f36d6a7a5c09a23e = (name = \"modal-control\")=>{\n    if (\"customElements\" in window) customElements.define(name, (0, $1c1612fc3437cf32$export$2e2bcd8739ae039));\n};\n\n\n(0, $f9ccc1fa0d22629a$export$f36d6a7a5c09a23e)();\n\n})();\n//# sourceMappingURL=global.js.map\n","import { define } from \"./index.js\";\n\ndefine();\n","import ModalControlElement from './ModalControlElement.js';\nimport ModalController from './ModalController.js';\n\n/**\n * @param {string} [name]\n * @returns {void}\n */\nconst define = (name = 'modal-control') => {\n  if ('customElements' in window) {\n    customElements.define(name, ModalControlElement);\n  }\n};\n\nexport { ModalControlElement, ModalController, define };\n","import ModalController from \"./ModalController.js\";\n\n/**\n * @customElement modal-control\n * @attr target - ID of the target `<dialog>`\n * @attr {'toggle'|'show'|'hide'} target-action - What should happen to the dialog when clicking the control (default: 'toggle')\n * @attr light-dismiss - If present, the modal will be closeable by clicking outside of it\n * @fires modal-control-before-toggle\n * @fires modal-control-toggle\n */\nexport default class ModalControlElement extends HTMLElement {\n  /** @type {string | null} */\n  #target = null;\n  /** @type {'toggle' | 'show' | 'hide'} */\n  #targetAction = 'toggle';\n  /** @type {boolean} */\n  #lightDismiss = false;\n  /** @type {ModalController | undefined} */\n  #controller;\n\n  static observedAttributes = ['target', 'target-action', 'light-dismiss'];\n\n  /**\n   * @param {string}  name\n   * @param {string | undefined}     _oldVal\n   * @param {string | undefined}     newVal\n   */\n  attributeChangedCallback(name, _oldVal, newVal) {\n    if (name === 'target') {\n      this.#target = newVal || null;\n    }\n\n    if (\n      name === 'target-action' &&\n      newVal &&\n      ['toggle', 'show', 'hide'].includes(newVal)\n    ) {\n      this.#targetAction = /** @type {'toggle' | 'show' | 'hide'} */ (newVal);\n    }\n\n    if (name === 'light-dismiss') {\n      this.#lightDismiss = newVal !== undefined;\n    }\n\n    if (name === 'target' || name === 'light-dismiss') {\n      this.#initController();\n    }\n  }\n\n  /**\n   * ID of the target `<dialog>`\n   * @type {string|null}\n   */\n  get target() {\n    return this.#target;\n  }\n\n  set target(value) {\n    this.#target = value;\n\n    if (value === null) {\n      this.removeAttribute('target');\n    } else {\n      this.setAttribute('target', value);\n    }\n  }\n\n  /**\n   * What should happen to the dialog when clicking the control (default: 'toggle')\n   * @type {'toggle'|'show'|'hide'}\n   */\n  get targetAction() {\n    return this.#targetAction;\n  }\n\n  set targetAction(value) {\n    if (!value) {\n      return;\n    }\n\n    this.#targetAction = value;\n\n    if (value === null) {\n      this.removeAttribute('target-action');\n    } else {\n      this.setAttribute('target-action', value);\n    }\n  }\n\n  /**\n   * Determines how the user can close the target modal\n   * @type {boolean}\n   */\n  get lightDismiss() {\n    return this.#lightDismiss;\n  }\n\n  set lightDismiss(value) {\n    this.#lightDismiss = Boolean(value);\n\n    if (this.#lightDismiss) {\n      this.setAttribute('light-dismiss', '');\n    } else {\n      this.removeAttribute('light-dismiss');\n    }\n  }\n\n  /** @type {HTMLDialogElement|null} */\n  get targetElement() {\n    const root = /** @type {Document|ShadowRoot} */ (this.getRootNode());\n    const el = this.target ? root.getElementById(this.target) : null;\n\n    if (!(el instanceof HTMLDialogElement)) {\n      return null;\n    }\n\n    return el;\n  }\n\n  connectedCallback() {\n    this.addEventListener('click', this.#handleClick);\n    this.#initController();\n  }\n\n  disconnectedCallback() {\n    this.removeEventListener('click', this.#handleClick);\n  }\n\n  #initController() {\n    const root = this.getRootNode();\n\n    if (root instanceof Document || root instanceof ShadowRoot) {\n      this.#controller = new ModalController(() => this.targetElement, {\n        lightDismiss: this.#lightDismiss,\n        canToggle: () => this.#dispatchBeforeToggle(),\n        onToggle: () => this.#dispatchToggle(),\n      });\n    }\n  }\n\n  /** @returns {boolean} */\n  #dispatchBeforeToggle() {\n    return this.dispatchEvent(\n      new Event('modal-control-before-toggle', { cancelable: true })\n    );\n  }\n\n  /** @returns {boolean} */\n  #dispatchToggle() {\n    return this.dispatchEvent(new Event('modal-control-toggle'));\n  }\n\n  /**\n   * @param {MouseEvent} event\n   * @returns {void}\n   */\n  #handleClick = event => {\n    const target = /** @type {Element} */ (event.target);\n\n    if (!target.closest('button, input[type=\"button\"]')) {\n      return;\n    }\n\n    switch (this.targetAction) {\n      case 'show':\n        this.#controller?.show();\n        break;\n      case 'hide':\n        this.#controller?.hide();\n        break;\n      case 'toggle':\n        this.#controller?.toggle();\n        break;\n    }\n  };\n}\n","import { deepContains } from \"./deepContains.js\";\nimport isEventInsideElement from \"./isEventInsideElement.js\";\n\n/**\n * @typedef {{\n *   lightDismiss?: boolean;\n *   canToggle?: () => boolean;\n *   onToggle?: () => void;\n * }} ModalOptions\n */\n\nexport default class ModalController {\n  #dialogOrGetter;\n  #options;\n  \n  /**\n   * @param {HTMLDialogElement | (() => HTMLDialogElement?)} dialog Element or getter\n   * @param {ModalOptions} [options]\n   */\n  constructor(dialog, options) {\n    const defaultOptions = { canToggle: () => true };\n    this.#dialogOrGetter = dialog;\n    this.#options = Object.assign(defaultOptions, options);\n  }\n\n  show() {\n    const dialog = this.#getDialog();\n\n    if (!dialog || dialog.matches(':modal') || !this.#options.canToggle?.()) {\n      return;\n    }\n    \n    const abortController = new AbortController();\n    dialog.showModal();\n\n    if (this.#options.lightDismiss) {\n      dialog.addEventListener(\n        'click',\n        (event) => {\n          if (!(event instanceof MouseEvent) || isEventInsideElement(event, dialog)) {\n            return;\n          }\n\n          this.hide();\n        },\n        { signal: abortController.signal }\n      );\n\n      setTimeout(() => {\n        const root = dialog.getRootNode();\n        \n        /** @param {Event} event */\n        const handleClickDirectRoot = (event) => {\n          // If the click is inside the dialog, ignore it\n          if (!(event instanceof MouseEvent) || isEventInsideElement(event, dialog)) {\n            return;\n          }\n\n          this.hide();\n        };\n\n        if (root instanceof ShadowRoot) {\n          root.addEventListener(\n            'click',\n            handleClickDirectRoot,\n            { signal: abortController.signal }\n          );\n\n          dialog.getRootNode({ composed: true }).addEventListener(\n            'click',\n            (event) => {\n              // If the target is an ancestor of the dialog, ignore the click\n              // (the shadow click handler should take care of anything inside\n              // the target that's not the dialog)\n              if (!(event.target instanceof Node) || deepContains(event.target, dialog)) {\n                return;\n              }\n\n              this.hide();\n            },\n            { signal: abortController.signal }\n          );\n        } else {\n          root.addEventListener(\n            'click',\n            handleClickDirectRoot,\n            { signal: abortController.signal }\n          );\n        }\n\n        dialog.addEventListener(\n          'close',\n          () => abortController.abort(),\n          { signal: abortController.signal }\n        );\n      }, 0);\n    }\n\n    this.#options.onToggle?.();\n  }\n\n  hide() {\n    const dialog = this.#getDialog();\n\n    if (!dialog || dialog.matches(':not(:modal)') || !this.#options.canToggle?.()) {\n      return;\n    }\n\n    dialog.close();\n    this.#options.onToggle?.();\n  }\n\n  toggle() {\n    if (this.#getDialog()?.matches(':modal')) {\n      this.hide();\n    } else {\n      this.show();\n    }\n  }\n\n  #getDialog() {\n    if (typeof this.#dialogOrGetter === 'function') {\n      return this.#dialogOrGetter();\n    }\n\n    return this.#dialogOrGetter;\n  }\n}\n","/**\n * Checks if an ancestor node contains a descendant node, crossing shadow\n * boundaries\n * @param {Node} ancestor\n * @param {Node} descendant\n */\nexport function deepContains(ancestor, descendant) {\n  // First, check via normal contains (fastest, but doesn't work with shadow\n  // roots)\n  if (ancestor.contains(descendant)) {\n    return true;\n  }\n\n  // This could be a shadow root or a document\n  const root = descendant.getRootNode();\n\n  if (root instanceof ShadowRoot) {\n    // Check the host of the shadow root\n    return deepContains(ancestor, root.host);\n  }\n\n  // If it's not a shadow root and contains() returned false, it's definitely\n  // not a match\n  return false;\n}\n","import { deepContains } from \"./deepContains.js\";\n\n/**\n * @param {MouseEvent}  event\n * @param {HTMLDialogElement} dialog\n * @returns {boolean}\n */\nexport default function isEventInsideElement(event, dialog) {\n  const { clientX, clientY } = event;\n  const target = /** @type {Node} */ (event.target);\n  const { x, y, width, height } = dialog.getBoundingClientRect();\n\n  // If the target IS the dialog, check that the event is inside the bounds. A\n  // click on the backdrop of a dialog will appear as a click on the dialog\n  // itself, but will be outside the bounds.\n  if (dialog === target) {\n    return (\n      clientX >= x &&\n      clientX <= x + width &&\n      clientY >= y &&\n      clientY <= y + height\n    );\n  }\n\n  // If the target isn't the dialog itself, check that it's inside the dialog\n  return deepContains(dialog, target);\n}"],"names":["$94c65141d6f98e31$export$273cb3019e2f952c","ancestor","descendant","contains","root","getRootNode","ShadowRoot","host","$01775cf5aedf1ce5$export$2e2bcd8739ae039","event","dialog","clientX","clientY","target","x","y","width","height","getBoundingClientRect","$c4fcd758eb800389$export$2e2bcd8739ae039","dialogOrGetter","options","constructor","Object","assign","canToggle","show","getDialog","matches","abortController","AbortController","showModal","lightDismiss","addEventListener","MouseEvent","hide","signal","setTimeout","handleClickDirectRoot","composed","Node","abort","onToggle","close","toggle","$1c1612fc3437cf32$export$2e2bcd8739ae039","HTMLElement","targetAction","controller","observedAttributes","attributeChangedCallback","name","_oldVal","newVal","includes","undefined","initController","value","removeAttribute","setAttribute","Boolean","targetElement","el","getElementById","HTMLDialogElement","connectedCallback","handleClick","disconnectedCallback","removeEventListener","Document","dispatchBeforeToggle","dispatchToggle","dispatchEvent","Event","cancelable","closest","window","customElements","define"],"version":3,"file":"global.js.map"}